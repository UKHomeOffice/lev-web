'use strict';

const _ = require('lodash');
const moment = require('moment');
const rewire = require('rewire');
const helpers = rewire('../../../api/helpers');

const record = {
  'date': '2012-08-09',
  'location': {
    'name': 'Manchester, Manchester, Metropolitan District of Manchester',
    'nameQualifier': 'generated by concatenating registrationDistrict, subDistrict and administrativeArea',
    'registrationDistrict': 'Manchester',
    'subDistrict': 'Manchester',
    'administrativeArea': 'Metropolitan District of Manchester'
  },
  'registrarSignature': 'J. Smith',
  'type': 'birth',
  'id': 1,
  'subjects': {
    'child': {
      'name': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      },
      'birthplace': 'Kensington',
      'dateOfBirth': '2012-08-08',
      'sex': 'Indeterminate',
      'originalName': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      }
    },
    'father': {
      'name': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      },
      'birthplace': 'Kensington',
      'occupation': 'Carpenter'
    },
    'mother': {
      'name': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      },
      'birthplace': 'Kensington',
      'occupation': 'Carpenter',
      'maidenSurname': 'Black',
      'marriageSurname': 'White',
      'usualAddress': '34 Matriarchs Place, Mumstown, Mumford'
    },
    'informant': {
      'name': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      },
      'usualAddress': '34 Matriarchs Place, Mumstown, Mumford',
      'qualification': 'Mother',
      'signature': 'J. Smith'
    }
  },
  'systemNumber': 1,
  'status': {
    'potentiallyFictitiousBirth': false,
    'correction': 'None',
    'cancelled': false,
    'blockedRegistration': false,
    'marginalNote': 'None',
    'reRegistered': 'None'
  },
  'previousRegistration': {
    'date': '2012-08-09',
    'systemNumber': 1
  }
};
const expected = {
  'system-number': 1,
  surname: 'Smith',
  forenames: 'Joan Narcissus Ouroboros',
  dob: '08/08/2012',
  gender: 'Indeterminate',
  'birth-place': 'Kensington',
  mother: {
    name: 'Joan Narcissus Ouroboros Smith',
    nee: 'Black',
    marriageSurname: 'White',
    'birth-place': 'Kensington',
    occupation: 'Carpenter'
  },
  father: {
    name: 'Joan Narcissus Ouroboros Smith',
    'birth-place': 'Kensington',
    occupation: 'Carpenter'
  },
  registered: {
    by: 'Mother',
    district: 'Manchester',
    'sub-district': 'Manchester',
    'admin-area': 'Metropolitan District of Manchester',
    date: '09/08/2012'
  },
  status: {
    refer: false,
    fatherAdded: false,
    subsequentlyMarried: false,
    fatherModified: false,
    replaced: false,
    corrected: false,
    courtOrderInPlace: false,
    courtOrderRevoked: false
  },
  previousRegistration: {
    date: '2012-08-09',
    systemNumber: 1
  }
};
const blocked = {
  'system-number': 1,
  surname: 'UNAVAILABLE',
  forenames: 'UNAVAILABLE',
  dob: 'UNAVAILABLE',
  gender: 'UNAVAILABLE',
  'birth-place': 'UNAVAILABLE',
  mother: {
    name: 'UNAVAILABLE',
    nee: 'UNAVAILABLE',
    marriageSurname: 'UNAVAILABLE',
    'birth-place': 'UNAVAILABLE',
    occupation: 'UNAVAILABLE'
  },
  father: {
    name: 'UNAVAILABLE',
    'birth-place': 'UNAVAILABLE',
    occupation: 'UNAVAILABLE'
  },
  registered: {
    by: 'UNAVAILABLE',
    district: 'UNAVAILABLE',
    'sub-district': 'UNAVAILABLE',
    'admin-area': 'UNAVAILABLE',
    date: 'UNAVAILABLE'
  },
  status: {
    refer: true
  },
  previousRegistration: {
    date: null,
    systemNumber: null
  }
};

/* eslint-disable no-underscore-dangle */
const buildBirthParams = helpers.__get__('buildBirthParams');
const buildAuditParams = helpers.__get__('buildAuditParams');
const buildQueryUri = helpers.__get__('buildQueryUri');
/* eslint-enable no-underscore-dangle */

describe('api/helpers.js', () => {
  describe('buildBirthParams', () => {
    it('should copy attributes from the input object to the output', () => {
      expect(buildBirthParams({
        surname: 'billson',
        forenames: 'bill',
        dob: '01/01/2011'
      })).to.deep.equal({
        lastname: 'billson',
        forenames: 'bill',
        dateofbirth: '2011-01-01'
      });
    });
    it('should only copy attributes with a value', () => {
      expect(buildBirthParams({
        surname: '',
        forenames: undefined,
        dob: null
      })).to.deep.equal({});
      expect(buildBirthParams({})).to.deep.equal({});
    });
    it('should change the date format to ISO', () => {
      expect(buildBirthParams({ dob: '30/01/2001' })).to.deep.equal({ dateofbirth: '2001-01-30' });
    });
  });

  describe('buildAuditParams', () => {
    it('should change the dates to ISO format', () => {
      expect(buildAuditParams({
        from: moment('31/01/2010', 'DD/MM/YYYY'),
        to: moment('13/01/2010', 'DD/MM/YYYY')
      })).to.deep.equal({
        from: '2010-01-31',
        to: '2010-01-13'
      });
    });
    it('should not add an empty user filter value', () => {
      expect(buildAuditParams({
        from: moment('31/01/2010', 'DD/MM/YYYY'),
        to: moment('13/01/2010', 'DD/MM/YYYY'),
        user: ''
      })).to.deep.equal({
        from: '2010-01-31',
        to: '2010-01-13'
      });
    });
    it('should add a non empty user filter value', () => {
      expect(buildAuditParams({
        from: moment('31/01/2010', 'DD/MM/YYYY'),
        to: moment('13/01/2010', 'DD/MM/YYYY'),
        user: 'chuck'
      })).to.deep.equal({
        from: '2010-01-31',
        to: '2010-01-13',
        user: 'chuck'
      });
    });
  });

  describe('buildQueryUri', () => {
    it('should return the endpoint if the "attrs" object is missing', () => {
      expect(buildQueryUri('uri')).to.equal('uri');
      expect(buildQueryUri('uri', null)).to.equal('uri');
      expect(buildQueryUri('uri', undefined)).to.equal('uri');
      expect(buildQueryUri('uri', false)).to.equal('uri');
    });
    it('should return the audit URI if required "from" and "to" attributes are present', () => {
      expect(buildQueryUri('audit/user-activity', {
        from: moment('31/01/2010', 'DD/MM/YYYY'),
        to: moment('13/01/2010', 'DD/MM/YYYY')
      })).to.deep.equal('audit/user-activity?from=2010-01-31&to=2010-01-13');
    });
    it('should otherwise return a standard birth URI', () => {
      expect(buildQueryUri('events/births', { surname: 'Craig' })).to.equal('events/births?lastname=Craig');
    });
  });

  describe('processRecord()', () => {
    it('is a function', () => (typeof helpers.processRecord).should.equal('function'));
    it('takes one argument', () => helpers.processRecord.should.have.lengthOf(1));

    describe('when called with an argument that is a valid record', () => {
      let result;
      let myRecord;

      before(() => {
        result = helpers.processRecord(record);
      });

      it('returns a processed record', () => result.should.eql(expected));

      describe('that is blocked', () => {
        before(() => {
          myRecord = _.cloneDeep(record);
          myRecord.status.blockedRegistration = true;
          result = helpers.processRecord(myRecord);
        });

        it('returns a censored record', () => result.should.eql(blocked));
      });

      describe('that is a re-registration due to an unexpected reason', () => {
        before(() => {
          myRecord = _.cloneDeep(record);
          myRecord.status.reRegistered = 'unexpected';
          result = helpers.processRecord(myRecord);
        });

        it('returns a record with the refer status', () => result.status.refer.should.equal(true));
      });

      describe('that is a marked as potentially fictitious', () => {
        before(() => {
          myRecord = _.cloneDeep(record);
          myRecord.status.potentiallyFictitiousBirth = true;
          result = helpers.processRecord(myRecord);
        });

        it('returns a record with the refer status', () => result.status.refer.should.equal(true));
      });

      describe('that has an unexpected marginal note', () => {
        before(() => {
          myRecord = _.cloneDeep(record);
          myRecord.status.marginalNote = 'unexpected';
          result = helpers.processRecord(myRecord);
        });

        it('returns a record with the refer status', () => result.status.refer.should.equal(true));
      });

      describe('that is marked as cancelled', () => {
        before(() => {
          myRecord = _.cloneDeep(record);
          myRecord.status.cancelled = true;
          result = helpers.processRecord(myRecord);
        });

        it('returns a record with the refer status', () => result.status.refer.should.equal(true));
      });
    });
  });
});
