'use strict';

const _ = require('lodash');
const moment = require('moment');
const proxyquire = require('proxyquire');
const config = require('../../../config');

const response = {
  'date': '2012-08-09',
  'location': {
    'name': 'Manchester, Manchester, Metropolitan District of Manchester',
    'nameQualifier': 'generated by concatenating registrationDistrict, subDistrict and administrativeArea',
    'registrationDistrict': 'Manchester',
    'subDistrict': 'Manchester',
    'administrativeArea': 'Metropolitan District of Manchester'
  },
  'registrarSignature': 'J. Smith',
  'type': 'birth',
  'id': 1,
  'subjects': {
    'child': {
      'name': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      },
      'birthplace': 'Kensington',
      'dateOfBirth': '2012-08-08',
      'sex': 'Indeterminate',
      'originalName': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      }
    },
    'father': {
      'name': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      },
      'birthplace': 'Kensington',
      'occupation': 'Carpenter'
    },
    'mother': {
      'name': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      },
      'birthplace': 'Kensington',
      'occupation': 'Carpenter',
      'maidenSurname': 'Black',
      'marriageSurname': 'White',
      'usualAddress': '34 Matriarchs Place, Mumstown, Mumford'
    },
    'informant': {
      'name': {
        'givenName': 'Joan Narcissus Ouroboros',
        'surname': 'Smith',
        'fullName': 'Joan Narcissus Ouroboros Smith',
        'qualifier': 'generated from prepending forename to surname'
      },
      'usualAddress': '34 Matriarchs Place, Mumstown, Mumford',
      'qualification': 'Mother',
      'signature': 'J. Smith'
    }
  },
  'systemNumber': 1,
  'status': {
    'potentiallyFictitiousBirth': false,
    'correction': 'None',
    'cancelled': false,
    'blockedRegistration': false,
    'marginalNote': 'None',
    'reRegistered': 'None'
  },
  'previousRegistration': {
    'date': '2012-08-09',
    'systemNumber': 1
  }
};
const parsedResponse = {
  'system-number': 1,
  surname: 'Smith',
  forenames: 'Joan Narcissus Ouroboros',
  dob: '08/08/2012',
  gender: 'Indeterminate',
  'birth-place': 'Kensington',
  mother: {
    name: 'Joan Narcissus Ouroboros Smith',
    nee: 'Black',
    marriageSurname: 'White',
    'birth-place': 'Kensington',
    occupation: 'Carpenter'
  },
  father: {
    name: 'Joan Narcissus Ouroboros Smith',
    'birth-place': 'Kensington',
    occupation: 'Carpenter'
  },
  registered: {
    by: 'Mother',
    district: 'Manchester',
    'sub-district': 'Manchester',
    'admin-area': 'Metropolitan District of Manchester',
    date: '09/08/2012'
  },
  status: {
    refer: false,
    fatherAdded: false,
    subsequentlyMarried: false,
    fatherModified: false,
    replaced: false,
    corrected: false,
    courtOrderInPlace: false,
    courtOrderRevoked: false
  },
  previousRegistration: {
    date: '2012-08-09',
    systemNumber: 1
  }
};

const partnershipResponse = {
  'id': 999999910,
  'dateOfPartnership': '2012-02-29',
  'placeOfPartnership': {
    'address': 'Test place',
    'short': 'Test place'
  },
  'registrar': {
    'signature': 'A. Registrar'
  },
  'partner1': {
    'prefix': null,
    'forenames': 'Tester',
    'surname': 'SOLO',
    'suffix': null,
    'dob': '1912-02-29',
    'sex': 'Female',
    'occupation': 'Unemployed',
    'retired': false,
    'address': '10 Test street',
    'aliases': [
      {
        'prefix': null,
        'forenames': 'Test Previous',
        'surname': 'Smithers',
        'suffix': null
      }, {
        'prefix': null,
        'forenames': null,
        'surname': null,
        'suffix': null
      }
    ],
    'signature': 'T. Solo',
    'condition': 'Single'
  },
  'partner2': {
    'prefix': null,
    'forenames': 'Test',
    'surname': 'BRIDE',
    'suffix': null,
    'dob': '2008-08-08',
    'sex': 'Female',
    'occupation': 'Bride',
    'retired': false,
    'address': null,
    'aliases': [
      {
        'prefix': null,
        'forenames': 'Test Former',
        'surname': 'SMITHE',
        'suffix': null
      },
      {
        'prefix': null,
        'forenames': null,
        'surname': null,
        'suffix': null
      }
    ],
    'signature': 'T. Bride',
    'condition': 'Single'
  },
  'fatherOfPartner1': {
    'forenames': 'Test Fop1',
    'surname': 'FATHER',
    'occupation': 'Father',
    'retired': true,
    'designation': null,
    'deceased': true
  },
  'motherOfPartner1': {
    'forenames': 'Serah Mop1',
    'surname': 'MOTHER',
    'occupation': 'Mother',
    'retired': true,
    'designation': null,
    'deceased': true
  },
  'fatherOfPartner2': {
    'forenames': 'Test Fop2',
    'surname': 'FATHER',
    'occupation': 'Father',
    'retired': true,
    'designation': null,
    'deceased': true
  },
  'motherOfPartner2': {
    'forenames': 'Serah Mop2',
    'surname': 'MOTHER',
    'occupation': 'Mother',
    'retired': true,
    'designation': null,
    'deceased': true
  },
  'witness1': {
    'forename': 'Arthur',
    'surname': 'Witness'
  },
  'witness2': {
    'forename': 'Abernathy',
    'surname': 'Other'
  },
  'status': {
    'blocked': false,
    'marginalNote': 'None'
  },
  'nextRegistration': null,
  'previousRegistration': null
};
const parsedPartnershipResponse = {
  id: 999999910,
  dateOfPartnership: '29/02/2012',
  placeOfPartnership: {
    address: 'Test place',
    short: 'Test place'
  },
  registrar: {
    signature: 'A. Registrar'
  },
  partner1: {
    prefix: null,
    forenames: 'Tester',
    surname: 'SOLO',
    suffix: null,
    dob: '29/02/1912',
    sex: 'Female',
    occupation: 'Unemployed',
    retired: false,
    address: '10 Test street',
    aliases: [
      {
        prefix: null,
        forenames: 'Test Previous',
        surname: 'Smithers',
        suffix: null
      }, {
        prefix: null,
        forenames: null,
        surname: null,
        suffix: null
      }
    ],
    signature: 'T. Solo',
    condition: 'Single'
  },
  partner2: {
    prefix: null,
    forenames: 'Test',
    surname: 'BRIDE',
    suffix: null,
    dob: '08/08/2008',
    sex: 'Female',
    occupation: 'Bride',
    retired: false,
    address: null,
    aliases: [
      {
        prefix: null,
        forenames: 'Test Former',
        surname: 'SMITHE',
        suffix: null
      }, {
        prefix: null,
        forenames: null,
        surname: null,
        suffix: null
      }
    ],
    signature: 'T. Bride',
    condition: 'Single'
  },
  fatherOfPartner1: {
    forenames: 'Test Fop1',
    surname: 'FATHER',
    occupation: 'Father',
    retired: true,
    designation: null,
    deceased: true
  },
  motherOfPartner1: {
    forenames: 'Serah Mop1',
    surname: 'MOTHER',
    occupation: 'Mother',
    retired: true,
    designation: null,
    deceased: true
  },
  fatherOfPartner2: {
    forenames: 'Test Fop2',
    surname: 'FATHER',
    occupation: 'Father',
    retired: true,
    designation: null,
    deceased: true
  },
  motherOfPartner2: {
    forenames: 'Serah Mop2',
    surname: 'MOTHER',
    occupation: 'Mother',
    retired: true,
    designation: null,
    deceased: true
  },
  witness1: {
    forename: 'Arthur',
    surname: 'Witness'
  },
  witness2: {
    forename: 'Abernathy',
    surname: 'Other'
  },
  status: {
    refer: false
  },
  nextRegistration: {
    systemNumber: null,
  },
  previousRegistration: {
    systemNumber: null,
  }
};

const accessToken = 'access_token';
const ri = { token: accessToken };
const expectedHeaders = {
  'Authorization': 'Bearer ' + accessToken,
  'X-Auth-Username': 'user',
  'X-Auth-Aud': 'client'
};

describe('api/index.js', () => {
  let api;
  const requestGet = sinon.stub();
  this.resetStubs = true;

  before(() => {
    const request = require('request');
    request.get = requestGet;
    api = proxyquire('../../../api', {
      request: request,
      '../config': _.extend(config, {
        api: {
          protocol: 'http',
          host: 'testhost.com',
          port: 1111,
          username: 'user',
          clientName: 'client'
        }
      })
    });
  });

  beforeEach(() => {
    if (this.resetStubs) {
      requestGet.reset();
    }
  });

  describe('births', () => {
    describe('findByNameDOB()', () => {
      it('is a function', () => api.findByNameDOB.should.be.a('function'));
      it('takes two arguments', () => api.findByNameDOB.should.have.lengthOf(2));

      describe('when called with no arguments', () => {
        it('throws a ReferenceError', () => expect(() => api.findByNameDOB()).to.throw(ReferenceError));
      });

      describe('when called with two arguments', () => {
        describe('and the first IS NOT an object', () => {
          it('throws a TypeError', () => expect(() => api.findByNameDOB(0, '')).to.throw(TypeError));
        });

        describe('and the first IS an object', () => {
          describe('and the second IS NOT a string', () => {
            it('throws a TypeError', () => expect(() => api.findByNameDOB({}, 0)).to.throw(TypeError));
          });

          describe('and the second IS a string', () => {
            let result;

            describe('should', () => {
              before(() => {
                this.resetStubs = false;
                const query = {
                  surname: 'SURNAME',
                  'forenames': 'FIRST SECOND',
                  dob: '01/01/2001'
                };

                result = api.findByNameDOB(query, ri);
              });

              it('make a request using the correct query string and adds auth headers', () =>
                requestGet.should.have.been.calledWith({
                  headers: expectedHeaders,
                  url: 'http://testhost.com:1111/api/v0/events/birth'
                    + '?lastname=SURNAME&forenames=FIRST%20SECOND&dateofbirth=2001-01-01',
                  agentOptions: {
                    rejectUnauthorized: true
                  }
                }));
              it('then return a promise', () => result.should.be.instanceOf(Promise));

              after(() => {
                this.resetStubs = true;
              });
            });

            describe('when the api returns a valid list of records', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 200 }, JSON.stringify([response]));
                result = api.findByNameDOB({}, {});
              });

              it('resolves to a processed record', () =>
                result.should.eventually.eql([parsedResponse]));
            });

            describe('when the api returns invalid JSON', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 200 }, '[}');
                result = api.findByNameDOB({}, {});
              });

              it('rejects with an error', () =>
                result.should.be.rejectedWith(Error));
            });

            describe('when the api gives a 404', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 404 }, '');
                result = api.findByNameDOB({}, {});
              });

              it('rejects with a \'NotFoundError\' error', () =>
                result.should.be.rejectedWith(Error, 'Received status code "404" from API'));
            });

            describe('when the api gives a 401', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 401 }, '');
                result = api.findByNameDOB({}, {});
              });

              it('rejects with a \'NotAuthorized\' error', () =>
                result.should.be.rejectedWith(Error, 'Received status code "401" from API'));
            });

            describe('when something else happens', () => {
              before(() => {
                requestGet.yields(new Error('Something else happened'));
                result = api.findByNameDOB({}, {});
              });

              it('rejects with an error', () =>
                result.should.be.rejectedWith(Error, 'Something else happened'));
            });
          });
        });
      });
    });

    describe('findBirths()', () => {
      it('is a function', () => api.findBirths.should.be.a('function'));
      it('takes two arguments', () => api.findBirths.should.have.lengthOf(2));

      describe('when called with no arguments', () => {
        it('throws a ReferenceError', () => expect(() => api.findBirths()).to.throw(ReferenceError));
      });

      describe('when called with two arguments', () => {
        describe('and the first IS NOT an object', () => {
          it('throws a TypeError', () => expect(() => api.findBirths(0, '')).to.throw(TypeError));
        });

        describe('and the first IS an object', () => {
          describe('and the second IS NOT a string', () => {
            it('throws a TypeError', () => expect(() => api.findBirths({}, 0)).to.throw(TypeError));
          });

          describe('and the second IS a string', () => {
            let result;
            let query;
            const read = () => api.findBirths(query, ri);

            describe('and the first DOES NOT contain a \'system-number\' property', () => {

              describe('should', () => {
                before(() => {
                  this.resetStubs = false;
                  query = {
                    surname: 'SURNAME',
                    forenames: 'FIRST SECOND',
                    dob: '01/01/2001'
                  };
                  result = read();
                });

                it('make a request using the correct query string and adds auth headers', () =>
                  requestGet.should.have.been.calledWith({
                    headers: expectedHeaders,
                    url: 'http://testhost.com:1111/api/v0/events/birth'
                      + '?lastname=SURNAME&forenames=FIRST%20SECOND&dateofbirth=2001-01-01',
                    agentOptions: {
                      rejectUnauthorized: true
                    }
                  }));
                it('then return a promise', () => result.should.be.instanceOf(Promise));

                after(() => {
                  this.resetStubs = true;
                });
              });

              describe('when the api returns a valid list of records', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 200 }, JSON.stringify([response]));
                  result = read();
                });

                it('resolves to a processed record', () => result.should.eventually.eql([parsedResponse]));
              });

              describe('when the api returns invalid JSON', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 200 }, '[}');
                  result = read();
                });

                it('rejects with an error', () => result.should.be.rejectedWith(Error));
              });

              describe('when the api gives a 404', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 404 }, '');
                  result = read();
                });

                it('rejects with a \'NotFoundError\' error', () =>
                  result.should.be.rejectedWith(Error, 'Received status code "404" from API'));
              });

              describe('when the api gives a 401', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 401 }, '');
                  result = read();
                });

                it('rejects with a \'NotAuthorized\' error', () =>
                  result.should.be.rejectedWith(Error, 'Received status code "401" from API'));
              });

              describe('when something else happens', () => {
                before(() => {
                  requestGet.yields(new Error('Something else happened'));
                  result = read();
                });

                it('rejects with an error', () =>
                  result.should.be.rejectedWith(Error, 'Something else happened'));
              });
            });

            describe('and the first DOES contain a \'system-number\' property', () => {

              describe('should', () => {
                before(() => {
                  this.resetStubs = false;
                  query = {
                    'system-number': '400000001',
                    surname: 'SURNAME',
                    forenames: 'FIRST SECOND',
                    dob: '01/01/2001'
                  };
                  result = read();
                });

                it('make a request using the correct query string and adds auth headers', () =>
                  requestGet.should.have.been.calledWith({
                    headers: expectedHeaders,
                    url: 'http://testhost.com:1111/api/v0/events/birth/400000001',
                    agentOptions: {
                      rejectUnauthorized: true
                    }
                  }));
                it('then return a promise', () => result.should.be.instanceOf(Promise));

                after(() => {
                  this.resetStubs = true;
                });
              });

              describe('when the api returns a valid record', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 200 }, JSON.stringify(response));
                  result = read();
                });

                it('resolves to a singleton list containing the processed record', () =>
                  result.should.eventually.eql([parsedResponse]));
              });

              describe('when the api returns invalid JSON', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 200 }, '[}');
                  result = read();
                });

                it('rejects with an error', () => result.should.be.rejectedWith(Error));
              });

              describe('when the api gives a 404', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 404 }, '');
                  result = read();
                });

                it('rejects with a \'NotFoundError\' error', () =>
                  result.should.be.rejectedWith(Error, 'Received status code "404" from API'));
              });

              describe('when the api gives a 401', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 401 }, '');
                  result = read();
                });

                it('rejects with a \'NotAuthorized\' error', () =>
                  result.should.be.rejectedWith(Error, 'Received status code "401" from API'));
              });

              describe('when something else happens', () => {
                before(() => {
                  requestGet.yields(new Error('Something else happened'));
                  result = read();
                });

                it('rejects with an error', () => result.should.be.rejectedWith(Error, 'Something else happened'));
              });
            });
          });
        });
      });
    });

    describe('findBySystemNumber()', () => {
      it('is a function', () => api.findBySystemNumber.should.be.a('function'));
      it('takes two arguments', () => api.findBySystemNumber.should.have.lengthOf(2));

      describe('when called with no arguments', () => {
        it('throws a ReferenceError', () => expect(() => api.findBySystemNumber()).to.throw(ReferenceError));
      });

      describe('when called with two arguments', () => {
        describe('and the first IS NOT an integer', () => {
          it('throws a TypeError', () => expect(() => api.findBySystemNumber({}, '')).to.throw(TypeError));
        });

        describe('and the first IS an integer', () => {
          describe('and the second IS NOT a string', () => {
            it('throws a TypeError', () => expect(() => api.findBySystemNumber(0, 0)).to.throw(TypeError));
          });

          describe('and the second IS a string', () => {
            let result;

            describe('should', () => {
              before(() => {
                this.resetStubs = false;
                const id = 400000001;

                result = api.findBySystemNumber(id, ri);
              });

              it('makes a request using the correct query string and adds auth headers', () =>
                requestGet.should.have.been.calledWith({
                  headers: expectedHeaders,
                  url: 'http://testhost.com:1111/api/v0/events/birth/400000001',
                  agentOptions: {
                    rejectUnauthorized: true
                  }
                }));
              it('returns a promise', () => result.should.be.instanceOf(Promise));

              after(() => {
                this.resetStubs = true;
              });
            });

            describe('when the api returns a valid record', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 200 }, JSON.stringify(response));
                result = api.findBySystemNumber(0, {});
              });

              it('resolves to a processed record', () => result.should.eventually.eql(parsedResponse));
            });

            describe('when the api returns invalid JSON', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 200 }, '[}');
                result = api.findBySystemNumber(0, {});
              });

              it('rejects with an error', () => result.should.be.rejectedWith(Error));
            });

            describe('when the api gives a 404', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 404 }, '');
                result = api.findBySystemNumber(0, {});
              });

              it('rejects with a \'NotFoundError\' error', () =>
                result.should.be.rejectedWith(Error, 'Received status code "404" from API'));
            });

            describe('when the api gives a 401', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 401 }, '');
                result = api.findBySystemNumber(0, {});
              });

              it('rejects with a \'NotAuthorized\' error', () =>
                result.should.be.rejectedWith(Error, 'Received status code "401" from API'));
            });

            describe('when something else happens', () => {
              before(() => {
                requestGet.yields(new Error('Something else happened'));
                result = api.findBySystemNumber(0, {});
              });

              it('rejects with an error', () =>
                result.should.be.rejectedWith(Error, 'Something else happened'));
            });
          });
        });
      });
    });
  });

  describe('partnerships', () => {
    describe('findPartnershipsByNameDOP()', () => {
      it('is a function', () => api.findPartnershipsByNameDOP.should.be.a('function'));
      it('takes two arguments', () => api.findPartnershipsByNameDOP.should.have.lengthOf(2));

      describe('when called with no arguments', () => {
        it('throws a ReferenceError', () => expect(() => api.findPartnershipsByNameDOP()).to.throw(ReferenceError));
      });

      describe('when called with two arguments', () => {
        describe('and the first IS NOT an object', () => {
          it('throws a TypeError', () => expect(() => api.findPartnershipsByNameDOP(0, '')).to.throw(TypeError));
        });

        describe('and the first IS an object', () => {
          describe('and the second IS NOT a string', () => {
            it('throws a TypeError', () => expect(() => api.findPartnershipsByNameDOP({}, 0)).to.throw(TypeError));
          });

          describe('and the second IS a string', () => {
            let result;

            describe('should', () => {
              before(() => {
                this.resetStubs = false;
                const query = {
                  surname: 'SURNAME',
                  forenames: 'FIRST SECOND',
                  dop: '01/01/2001'
                };

                result = api.findPartnershipsByNameDOP(query, ri);
              });

              it('make a request using the correct query string and adds auth headers', () =>
                requestGet.should.have.been.calledWith({
                  headers: expectedHeaders,
                  url: 'http://testhost.com:1111/v1/registration/partnership'
                    + '?surname=SURNAME&forenames=FIRST%20SECOND&dateOfPartnership=2001-01-01',
                  agentOptions: {
                    rejectUnauthorized: true
                  }
                }));
              it('then return a promise', () => result.should.be.instanceOf(Promise));

              after(() => {
                this.resetStubs = true;
              });
            });

            describe('when the api returns a valid list of records', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 200 }, JSON.stringify([partnershipResponse]));
                result = api.findPartnershipsByNameDOP({}, {});
              });

              it('resolves to a processed record', () =>
                result.should.eventually.eql([parsedPartnershipResponse]));
            });

            describe('when the api returns invalid JSON', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 200 }, '[}');
                result = api.findPartnershipsByNameDOP({}, {});
              });

              it('rejects with an error', () =>
                result.should.be.rejectedWith(Error));
            });

            describe('when the api gives a 404', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 404 }, '');
                result = api.findPartnershipsByNameDOP({}, {});
              });

              it('rejects with a \'NotFoundError\' error', () =>
                result.should.be.rejectedWith(Error, 'Received status code "404" from API'));
            });

            describe('when the api gives a 401', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 401 }, '');
                result = api.findPartnershipsByNameDOP({}, {});
              });

              it('rejects with a \'NotAuthorized\' error', () =>
                result.should.be.rejectedWith(Error, 'Received status code "401" from API'));
            });

            describe('when something else happens', () => {
              before(() => {
                requestGet.yields(new Error('Something else happened'));
                result = api.findPartnershipsByNameDOP({}, {});
              });

              it('rejects with an error', () =>
                result.should.be.rejectedWith(Error, 'Something else happened'));
            });
          });
        });
      });
    });

    describe('findPartnerships()', () => {
      it('is a function', () => api.findPartnerships.should.be.a('function'));
      it('takes two arguments', () => api.findPartnerships.should.have.lengthOf(2));

      describe('when called with no arguments', () => {
        it('throws a ReferenceError', () => expect(() => api.findPartnerships()).to.throw(ReferenceError));
      });

      describe('when called with two arguments', () => {
        describe('and the first IS NOT an object', () => {
          it('throws a TypeError', () => expect(() => api.findPartnerships(0, '')).to.throw(TypeError));
        });

        describe('and the first IS an object', () => {
          describe('and the second IS NOT a string', () => {
            it('throws a TypeError', () => expect(() => api.findPartnerships({}, 0)).to.throw(TypeError));
          });

          describe('and the second IS a string', () => {
            let result;
            let query;
            const read = () => api.findPartnerships(query, ri);

            describe('and the first DOES NOT contain a \'system-number\' property', () => {

              describe('should', () => {
                before(() => {
                  this.resetStubs = false;
                  query = {
                    surname: 'SURNAME',
                    forenames: 'FIRST SECOND',
                    dop: '01/01/2001'
                  };
                  result = read();
                });

                it('make a request using the correct query string and adds auth headers', () =>
                  requestGet.should.have.been.calledWith({
                    headers: expectedHeaders,
                    url: 'http://testhost.com:1111/v1/registration/partnership'
                      + '?surname=SURNAME&forenames=FIRST%20SECOND&dateOfPartnership=2001-01-01',
                    agentOptions: {
                      rejectUnauthorized: true
                    }
                  }));
                it('then return a promise', () => result.should.be.instanceOf(Promise));

                after(() => {
                  this.resetStubs = true;
                });
              });

              describe('when the api returns a valid list of records', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 200 }, JSON.stringify([partnershipResponse]));
                  result = read();
                });

                it('resolves to a processed record', () => result.should.eventually.eql([parsedPartnershipResponse]));
              });

              describe('when the api returns invalid JSON', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 200 }, '[}');
                  result = read();
                });

                it('rejects with an error', () => result.should.be.rejectedWith(Error));
              });

              describe('when the api gives a 404', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 404 }, '');
                  result = read();
                });

                it('rejects with a \'NotFoundError\' error', () =>
                  result.should.be.rejectedWith(Error, 'Received status code "404" from API'));
              });

              describe('when the api gives a 401', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 401 }, '');
                  result = read();
                });

                it('rejects with a \'NotAuthorized\' error', () =>
                  result.should.be.rejectedWith(Error, 'Received status code "401" from API'));
              });

              describe('when something else happens', () => {
                before(() => {
                  requestGet.yields(new Error('Something else happened'));
                  result = read();
                });

                it('rejects with an error', () =>
                  result.should.be.rejectedWith(Error, 'Something else happened'));
              });
            });

            describe('and the first DOES contain a \'system-number\' property', () => {

              describe('should', () => {
                before(() => {
                  this.resetStubs = false;
                  query = {
                    'system-number': '400000001',
                    surname: 'SURNAME',
                    forenames: 'FIRST SECOND',
                    dop: '01/01/2001'
                  };
                  result = read();
                });

                it('make a request using the correct query string and adds auth headers', () =>
                  requestGet.should.have.been.calledWith({
                    headers: expectedHeaders,
                    url: 'http://testhost.com:1111/v1/registration/partnership/400000001',
                    agentOptions: {
                      rejectUnauthorized: true
                    }
                  }));
                it('then return a promise', () => result.should.be.instanceOf(Promise));

                after(() => {
                  this.resetStubs = true;
                });
              });

              describe('when the api returns a valid record', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 200 }, JSON.stringify(partnershipResponse));
                  result = read();
                });

                it('resolves to a singleton list containing the processed record', () =>
                  result.should.eventually.eql([parsedPartnershipResponse]));
              });

              describe('when the api returns invalid JSON', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 200 }, '[}');
                  result = read();
                });

                it('rejects with an error', () => result.should.be.rejectedWith(Error));
              });

              describe('when the api gives a 404', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 404 }, '');
                  result = read();
                });

                it('rejects with a \'NotFoundError\' error', () =>
                  result.should.be.rejectedWith(Error, 'Received status code "404" from API'));
              });

              describe('when the api gives a 401', () => {
                before(() => {
                  requestGet.yields(null, { statusCode: 401 }, '');
                  result = read();
                });

                it('rejects with a \'NotAuthorized\' error', () =>
                  result.should.be.rejectedWith(Error, 'Received status code "401" from API'));
              });

              describe('when something else happens', () => {
                before(() => {
                  requestGet.yields(new Error('Something else happened'));
                  result = read();
                });

                it('rejects with an error', () => result.should.be.rejectedWith(Error, 'Something else happened'));
              });
            });
          });
        });
      });
    });

    describe('findPartnershipBySystemNumber()', () => {
      it('is a function', () => api.findPartnershipBySystemNumber.should.be.a('function'));
      it('takes two arguments', () => api.findPartnershipBySystemNumber.should.have.lengthOf(2));

      describe('when called with no arguments', () => {
        it('throws a ReferenceError', () => expect(() => api.findPartnershipBySystemNumber()).to.throw(ReferenceError));
      });

      describe('when called with two arguments', () => {
        describe('and the first IS NOT an integer', () => {
          it('throws a TypeError', () => expect(() => api.findPartnershipBySystemNumber({}, '')).to.throw(TypeError));
        });

        describe('and the first IS an integer', () => {
          describe('and the second IS NOT a string', () => {
            it('throws a TypeError', () => expect(() => api.findPartnershipBySystemNumber(0, 0)).to.throw(TypeError));
          });

          describe('and the second IS a string', () => {
            let result;

            describe('should', () => {
              before(() => {
                this.resetStubs = false;
                const id = 400000001;

                result = api.findPartnershipBySystemNumber(id, ri);
              });

              it('makes a request using the correct query string and adds auth headers', () =>
                requestGet.should.have.been.calledWith({
                  headers: expectedHeaders,
                  url: 'http://testhost.com:1111/v1/registration/partnership/400000001',
                  agentOptions: {
                    rejectUnauthorized: true
                  }
                }));
              it('returns a promise', () => result.should.be.instanceOf(Promise));

              after(() => {
                this.resetStubs = true;
              });
            });

            describe('when the api returns a valid record', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 200 }, JSON.stringify(partnershipResponse));
                result = api.findPartnershipBySystemNumber(0, {});
              });

              it('resolves to a processed record', () => result.should.eventually.eql(parsedPartnershipResponse));
            });

            describe('when the api returns invalid JSON', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 200 }, '[}');
                result = api.findPartnershipBySystemNumber(0, {});
              });

              it('rejects with an error', () => result.should.be.rejectedWith(Error));
            });

            describe('when the api gives a 404', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 404 }, '');
                result = api.findPartnershipBySystemNumber(0, {});
              });

              it('rejects with a \'NotFoundError\' error', () =>
                result.should.be.rejectedWith(Error, 'Received status code "404" from API'));
            });

            describe('when the api gives a 401', () => {
              before(() => {
                requestGet.yields(null, { statusCode: 401 }, '');
                result = api.findPartnershipBySystemNumber(0, {});
              });

              it('rejects with a \'NotAuthorized\' error', () =>
                result.should.be.rejectedWith(Error, 'Received status code "401" from API'));
            });

            describe('when something else happens', () => {
              before(() => {
                requestGet.yields(new Error('Something else happened'));
                result = api.findPartnershipBySystemNumber(0, {});
              });

              it('rejects with an error', () =>
                result.should.be.rejectedWith(Error, 'Something else happened'));
            });
          });
        });
      });
    });
  });

  describe('userActivityReport()', () => {
    it('is a function', () => api.userActivityReport.should.be.a('function'));
    it('should throw a ReferenceError when no parameters are provided', () => {
      expect(api.userActivityReport).to.throw(ReferenceError);
    });

    describe('when called with an invalid system user', () => {
      it('should throw a TypeError if the `user` parameter is not a proper string', () => {
        expect(() => api.userActivityReport(ri, moment().add(-1, 'days'), moment(), null)).to.throw(TypeError);
        expect(() => api.userActivityReport(ri, moment().add(-1, 'days'), moment(), 42)).to.throw(TypeError);
      });
    });

    describe('when called without the required `from` or `to` dates', () => {
      it('should throw a ReferenceError if either parameter is omitted', () => {
        expect(from => api.userActivityReport(ri, from, moment())).to.throw(ReferenceError);
        expect(() => api.userActivityReport(ri, moment())).to.throw(ReferenceError);
      });
      it('should throw a TypeError if either parameter is not a `moment` date object', () => {
        expect(() => api.userActivityReport(ri, 'from', moment())).to.throw(TypeError);
        expect(() => api.userActivityReport(ri, moment(), 'to')).to.throw(TypeError);
      });
      it('should throw a RangeError if either parameter is not a valid date object', () => {
        expect(() => api.userActivityReport(ri, moment('from'), moment()))
          .to.throw(RangeError);
        expect(() => api.userActivityReport(ri, moment('2017-02-27'), moment('2017-02-29')))
          .to.throw(RangeError);
      });
    });

    describe('when called with valid dates', () => {
      it('should throw a RangeError if the `to` date is before `from`', () =>
        expect(() => api.userActivityReport(ri, moment().add(1, 'days'), moment())).to.throw(RangeError)
      );

      const days = config.MAX_AUDIT_RANGE + 1;
      it(`should throw a RangeError if the date range is greater than the ${config.MAX_AUDIT_RANGE} day limit`, () =>
        expect(() => api.userActivityReport(ri, moment().subtract(days, 'days'), moment()))
          .to.throw(RangeError, `less than ${config.MAX_AUDIT_RANGE} days`)
      );

      describe('as a proper range', () => {
        let result;
        const from = '2001-01-01';
        const to = '2001-02-01';

        before('try to get the user activity data', () => {
          this.resetStubs = false;
          result = api.userActivityReport(ri, moment(from), moment(to));
        });

        it('should make a request to the API', () =>
          requestGet.lastCall.should.have.been.calledWith({
            headers: expectedHeaders,
            url: `http://testhost.com:1111/api/v0/audit/user-activity?from=${from}&to=${to}`,
            agentOptions: {
              rejectUnauthorized: true
            }
          }));

        it('returns a promise', () => result.should.be.instanceOf(Promise));

        after(() => {
          this.resetStubs = true;
        });
      });
    });

    describe('when called with a user filter', () => {
      let result;
      const from = '2001-03-01';
      const to = '2001-04-01';

      before('try to get the user activity data', () => {
        this.resetStubs = false;
        result = api.userActivityReport(ri, moment(from), moment(to), 'fred');
      });

      it('should make a request to the API', () =>
        requestGet.lastCall.should.have.been.calledWith({
          headers: expectedHeaders,
          url: `http://testhost.com:1111/api/v0/audit/user-activity?from=${from}&to=${to}&user=fred`,
          agentOptions: {
            rejectUnauthorized: true
          }
        }));

      it('returns a promise', () => result.should.be.instanceOf(Promise));

      after(() => {
        this.resetStubs = true;
      });
    });
  });
});
